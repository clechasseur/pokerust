//! General helper macros used throughout the code.

/// Generates [`From`] implementations that can be used to forward [`Into`]
/// requests two level deep.
///
/// # Typical use case
///
/// Let's say you have type `ErrorA`, `ErrorB` and `ErrorC`, like so:
///
/// ```no_run
/// use thiserror::Error;
///
/// #[derive(Debug, Error)]
/// #[error("error C")]
/// pub struct ErrorC;
///
/// #[derive(Debug, Error)]
/// #[error("error B")]
/// pub struct ErrorB(#[from] ErrorC);
///
/// #[derive(Debug, Error)]
/// #[error("error A")]
/// pub struct ErrorA(#[from] ErrorB);
/// ```
///
/// [`thiserror`] helpfully generates the [`From`] `impl`s required to go from `ErrorB` to `ErrorA`
/// and from `ErrorC` to `ErrorB`, but there's no way to go from `ErrorC` to `ErrorA` directly:
///
/// ```compile_fail
/// # use thiserror::Error;
/// #
/// # #[derive(Debug, Error)]
/// # #[error("error C")]
/// # pub struct ErrorC;
/// #
/// # #[derive(Debug, Error)]
/// # #[error("error B")]
/// # pub struct ErrorB(#[from] ErrorC);
/// #
/// # #[derive(Debug, Error)]
/// # #[error("error A")]
/// # pub struct ErrorA(#[from] ErrorB);
/// #
/// let err_c = ErrorC;
/// let err_b: ErrorB = err_c.into(); // This works
/// let err_a: ErrorA = err_b.into(); // This works also
///
/// let err_c = ErrorC;
/// let err_a: ErrorA = err_c.into(); // error[E0277]: the trait bound `ErrorA: From<ErrorC>` is not satisfied
/// ```
///
/// Using this macro, you can generate the necessary intermediate [`From`] `impl`s:
///
/// ```no_run
/// # use thiserror::Error;
/// # use pokedex::forward_from;
/// #
/// # #[derive(Debug, Error)]
/// # #[error("error C")]
/// # pub struct ErrorC;
/// #
/// # #[derive(Debug, Error)]
/// # #[error("error B")]
/// # pub struct ErrorB(#[from] ErrorC);
/// #
/// # #[derive(Debug, Error)]
/// # #[error("error A")]
/// # pub struct ErrorA(#[from] ErrorB);
/// #
/// forward_from!(ErrorC => ErrorB => ErrorA);
///
/// let err_c = ErrorC;
/// let err_a: ErrorA = err_c.into(); // Magic!
/// ```
///
/// If there are many different starting types, the macro can be used to generate multiple [`From`]
/// `impl`s at once:
///
/// ```no_run
/// use thiserror::Error;
/// use pokedex::forward_from;
///
/// #[derive(Debug, Error)]
/// #[error("error C")]
/// pub struct ErrorC;
///
/// #[derive(Debug, Error)]
/// #[error("error D")]
/// pub struct ErrorD;
///
/// #[derive(Debug, Error)]
/// #[error("error B")]
/// pub enum ErrorB {
///     C(#[from] ErrorC),
///     D(#[from] ErrorD),
/// }
///
/// #[derive(Debug, Error)]
/// #[error("error A")]
/// pub struct ErrorA(#[from] ErrorB);
///
/// forward_from!(ErrorC, ErrorD => ErrorB => ErrorA);
///
/// let err_c = ErrorC;
/// let err_a: ErrorA = err_c.into(); // Magic!
///
/// let err_d = ErrorD;
/// let err_a: ErrorA = err_d.into(); // Also magic, etc.
/// ```
///
/// # Why we need this
///
/// It might be tempting to believe it should be possible to create a generic [`From`] bridge
/// `impl` going from any type `T` directly to `ErrorA` as long as there's an intermediate step
/// that goes from `T` to `ErrorB`:
///
/// ```compile_fail
/// use thiserror::Error;
///
/// #[derive(Debug, Error)]
/// #[error("error C")]
/// pub struct ErrorC;
///
/// #[derive(Debug, Error)]
/// #[error("error B")]
/// pub struct ErrorB(#[from] ErrorC);
///
/// #[derive(Debug, Error)]
/// #[error("error A")]
/// pub struct ErrorA(#[from] ErrorB);
///
/// impl<T> From<T> for ErrorA
/// where
///     T: Into<ErrorB>,
/// {
///     fn from(value: T) -> Self {
///         Into::<ErrorB>::into(value).into()
///     }
/// }
///
/// let err_c = ErrorC;
/// let err_a: ErrorA = err_c.into(); // error[E0119]: conflicting implementations of trait `From<ErrorB>` for type `ErrorA`
/// ```
///
/// What happened? The problem is that Rust's standard library has a reflexive implementation of
/// [`From`](From#impl-From<T>-for-T), so our generic [`From`] `impl` above actually matches for
/// `From<ErrorB> for ErrorA`. This was however already generated by [`thiserror`], so there's a
/// conflict.
///
/// Wait, we can just remove the [`From`] `impl` generated by [`thiserror`], then?
///
/// ```should_panic
/// use thiserror::Error;
///
/// #[derive(Debug, Error)]
/// #[error("error C")]
/// pub struct ErrorC;
///
/// #[derive(Debug, Error)]
/// #[error("error B")]
/// pub struct ErrorB(#[from] ErrorC);
///
/// #[derive(Debug, Error)]
/// #[error("error A")]
/// pub struct ErrorA(ErrorB); // No `#[from]` here to skip generating the conflicting `impl From<ErrorB> for ErrorA`
///
/// impl<T> From<T> for ErrorA
/// where
///     T: Into<ErrorB>,
/// {
///     fn from(value: T) -> Self {
///         Into::<ErrorB>::into(value).into()
///     }
/// }
///
/// let err_c = ErrorC;
/// let err_a: ErrorA = err_c.into(); // thread 'main' has overflowed its stack
/// ```
///
/// That doesn't work either because we've just created a recursive [`From`] `impl`: when matched
/// for `From<ErrorB> for ErrorA`, we call `Into::<ErrorB>::into(value)` which calls the same method
/// again, creating an infinite loop.
///
/// One possible solution would be for our generic [`From`] `impl` to match for any type `T` _except_
/// `ErrorB`. This would require Rust to implement **negative trait bounds**, but [it doesn't](https://github.com/rust-lang/rust/issues/42721).
///
/// There is an unstable feature called `negative_impls` ([tracking issue](https://github.com/rust-lang/rust/issues/68318)).
/// This allows us to publicly state that a certain type will never implement a particular trait:
///
/// ```ignore
/// #![feature(negative_impls)]
///
/// trait Foo {}
/// struct Bar {}
/// impl !Foo for Bar {}
/// ```
///
/// However, this doesn't help us either, because we _need_ an `impl From<ErrorB> for ErrorA` at
/// some point. In fact, we need two: one for going from `ErrorB` to `ErrorA` and one for going
/// from any type `T` _except_ `ErrorB` to `ErrorA`.
///
/// Another unstable feature that would appear to save us is [specialization](https://github.com/rust-lang/rfcs/pull/1210)
/// ([tracking issue](https://github.com/rust-lang/rust/issues/31844)). This allows us to create
/// overlapping trait `impl`s, as long as one is more specific - a bit like C++'s template rules.
/// ðŸŽ‰, right?
///
/// ```ignore
/// #![feature(specialization)]
///
/// use thiserror::Error;
///
/// #[derive(Debug, Error)]
/// #[error("error C")]
/// pub struct ErrorC;
///
/// #[derive(Debug, Error)]
/// #[error("error B")]
/// pub struct ErrorB(#[from] ErrorC);
///
/// #[derive(Debug, Error)]
/// #[error("error A")]
/// pub struct ErrorA(#[from] ErrorB);
///
/// impl<T> From<T> for ErrorA
/// where
///     T: Into<ErrorB>,
/// {
///     default fn from(value: T) -> Self { // Using `default` here allows more specialized `impl`s
///         Into::<ErrorB>::into(value).into()
///     }
/// }
///
/// let err_b = ErrorB(ErrorC);
/// let err_a: ErrorA = err_b.into(); // ðŸŽ‰! Works by using specialized `impl` generated by `thiserror`
///
/// let err_c = ErrorC;
/// let err_a: ErrorA = err_c.into(); // ðŸŽ‰! Works by using the generic `impl`
/// ```
///
/// Hurray! Unfortunately, `specialization` is not stable yet, so this would only work when building
/// with a Nightly Rust.
///
/// For now, we'll stick with this macro; when specialization lands, we can safely migrate away from it.
#[macro_export]
macro_rules! forward_from {
    ( $($start:ty),+ => $interm:ty => $final:ty ) => {
        $(
            impl From<$start> for $final {
                fn from(value: $start) -> Self {
                    Into::<$interm>::into(value).into()
                }
            }
        )+
    };
}

#[cfg(test)]
mod tests {
    use thiserror::Error;

    #[derive(Debug, PartialEq, Eq, Error)]
    #[error("error C: {0}")]
    struct ErrorC(&'static str);

    #[derive(Debug, PartialEq, Eq, Error)]
    #[error("error D: {0}")]
    struct ErrorD(&'static str);

    #[derive(Debug, PartialEq, Eq, Error)]
    #[error("error B")]
    enum ErrorB {
        C(#[from] ErrorC),
        D(#[from] ErrorD),
    }

    #[derive(Debug, PartialEq, Eq, Error)]
    #[error("error A")]
    struct ErrorA(#[from] ErrorB);

    forward_from!(ErrorC, ErrorD => ErrorB => ErrorA);

    #[test]
    fn test_forward_from() {
        let error_c = ErrorC("life");
        let error_a: ErrorA = error_c.into();
        assert_eq!(ErrorA(ErrorB::C(ErrorC("life"))), error_a);

        let error_d = ErrorD("hangar");
        let error_a: ErrorA = error_d.into();
        assert_eq!(ErrorA(ErrorB::D(ErrorD("hangar"))), error_a);
    }
}
